package com.craigegerton.nomoreboatexploit;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.plugin.PluginDescriptionFile;
import org.bukkit.plugin.java.JavaPlugin;

public class NoMoreBoatExploit extends JavaPlugin implements Listener
{
	private Logger log;
	private PluginDescriptionFile pdf;

	//Using names instead of UUID for nicer information later on
	private Map<String, Integer> loadedChunks = new HashMap<String, Integer>();

	//Scan parameters
	private int checkTime = 2;
	private int chunkThreshold = 200;
	
	//Detection parameters
	private List<String> commands = Arrays.asList("ban %player% Boat exploit");
	private boolean chunkCleanup = true;

	public void onEnable()
	{
		this.log = this.getLogger();
		this.pdf = this.getDescription();
		
		loadConfig();

		getServer().getPluginManager().registerEvents(this, this);

		log.info(pdf.getFullName()+" enabled successfully!");
	}

	public void onDisable()
	{
		log.info(pdf.getFullName()+" disabled successfully!");
	}
	
	private void loadConfig()
	{
		this.saveDefaultConfig();
		this.reloadConfig();
		
		this.checkTime = this.getConfig().getInt("scan.time", this.checkTime);
		this.chunkThreshold = this.getConfig().getInt("scan.chunkThreshold", this.chunkThreshold);
		
		if(this.chunkThreshold < 200) {
			log.warning("## WARNING ##############################");
			log.warning("#                                       #");
			log.warning("# YOUR CHUNK THRESHOLD IS RATHER LOW... #");
			log.warning("# THIS MAY RESULT IN INNOCENT PLAYERS   #");
			log.warning("# BEING AFFECTED...                     #");
			log.warning("#                                       #");
			log.warning("############################## WARNING ##");
		}
		
		this.commands = this.getConfig().getStringList("detection.commands");
		this.chunkCleanup = this.getConfig().getBoolean("detection.chunkCleanup", this.chunkCleanup);
	}
	
	@EventHandler(priority = EventPriority.MONITOR)
	public void onMoveToNewChunk(PlayerMoveEvent event)
	{
		//This explains itself...
		if(isSameChunk(event.getFrom(), event.getTo())) return;
		
		//Check if player is not affected by checks
		if(event.getPlayer().hasPermission("boatexploit.exempt")) return;

		final String player = event.getPlayer().getName();

		//If already being checked, just increment number and return
		if(loadedChunks.containsKey(player)) {
			loadedChunks.put(player, loadedChunks.get(player)+1);
			return;
		}

		//Start running check
		loadedChunks.put(player, 1);

		//Wait 2 seconds
		getServer().getScheduler().scheduleSyncDelayedTask(this, new Runnable() {
			public void run() {
				//Get the chunks loaded and remove from map
				Integer chunks = loadedChunks.remove(player);

				//Player didnt load too many chunks
				if(chunks == null || chunks < chunkThreshold) return;
				
				//Inform console
				log.info(String.format("%s loaded %s chunks in %s seconds...", player, chunks, checkTime));
				
				//Run commands
				for(String cmd : commands)
					Bukkit.dispatchCommand(Bukkit.getConsoleSender(), cmd.replaceAll("%player%", player));

				//Chunk cleanup
				if(chunkCleanup) {
					for(World world : Bukkit.getWorlds()) {
						for(Chunk chunk : world.getLoadedChunks()) {
							chunk.unload(true, true);
						}
					}
				}
			}
		}, checkTime*20L);
	}

	private boolean isSameChunk(Location one, Location two)
	{
		return one.getBlockX() >> 4 == two.getBlockX() >> 4 &&
				one.getBlockZ() >> 4 == two.getBlockZ() >> 4 &&
				one.getWorld() == two.getWorld();
	}
}
